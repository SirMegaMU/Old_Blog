---
layout: post
title: 导包与拆包
date: 2021-09-18
tags: Python
---

### 导入

**从非当前文件夹的其他目录中导入**

使用`sys.path`查看系统的环境变量，它会按优先级列出环境变量

要从其他地方导包，要先把该目录路径加入到环境变量中

~~~python
import sys
# 把该路径添加到末尾
sys.path.append("要添加的路径")
# 把该路径添加到指定位置
sys.path.insert(位置,"要添加的路径")
~~~

### 重新加载

使用`reload`来重新加载模块并创建模块对象。

* import 导入模块后，如果模块被修改，此时再次 import 不起作用

  > import 不能重复加载模块

* 强制重新加载一次模块

  reload() 函数

  > 1. from imp import reload
  > 2. reload(要重新加载的模块)

### 私有化

将变量名设置为`_`开头，可以使该变量不能被`from ... import *`导入。

**注意**：如果使用其他的方式导入模块，私有化将无效

### `import`与`from ... import ...`

* `import ...`直接引用了源模块的变量/函数/类的内存地址
* `from ... import ...`拷贝源模块的变量/函数/类到当前自己类

### 可变参数的拆包

* 可变参数 `*args`，`**kwargs`默认会封包过程
* 如果想要这种单数继续传递到下一个函数，传递的时候 `func(*args,**kwargs)`

###  单继承中的`super()`

* super() 使用的时候，传递参数的时候，self 不用传递

* super() 调用顺序，按照`__mro__`顺序来完成

  > `Grandson.__mro__`  是一个元组
  >
  > 当在类中使用 super() 在`__mro__`中找到当前类的下一个元素，调用该元素的方法 

 ### 多继承与MRO顺序

* 多继承中 super()  执行顺序，严格执行 MRO顺序表

* MRO顺序表：

  * 类名.mro()
  * `类名.__mro__`

* 注意：

  > 当在类中使用 super() 在  mro列表中找到当前类的下一个元素，调用该元素的方法 
  >
  > 多继承中，不建议使用类名 直接调用父类的方法

为了防止重复调用父类`__init__`，应该使用`super()`

