---
layout: post
title: Gil锁
date: 2021-09-15
tags: Python
---

### 正常情况下的CPU运作

我们先使用htop查看CPU占用情况

![htop界面](https://sirmegamu.github.io/images/posts/2021-09-15/01.png)

我们跑一个单线程死循环，发现它可以把一个CPU的性能给占满。

我们跑一个多进程死循环，发现它可以把多个CPU的性能给占满。

我们跑一个多线程死循环，发现它并不能把多个CPU 的性能占满，而是保持在一个大致相等的占用率上。

### GIL全局解释器锁

**同一时间，只有一个线程使用CPU**，一个进程只有一个GIL锁。

所以多线程实际上是伪并行。

**早期计算机都是单核的，GIL是“历史遗留问题”**

### GIL解决方案

**慎用！**

- 换一个解释器，如jython
- 使用多进程而不是多线程
- 使用其他语言写子进程部分





